<!DOCTYPE html>
<html>
<head>
<style type="text/css">
/* Page Background */
body {
  background-color: #3D2E00;
  background-image: linear-gradient(#3D2E00, #F5EBCC);
}
/* Boaord Border */
div#memory_board{
  background:#9933FF;
  border:#FF0000 20px solid;
  border-radius: 10px;
  width:800px;
  height:540px;
  padding:24px;
  margin:0px auto;
}
/* Tiles */
div#memory_board > div{
  background: url(http://img2.wikia.nocookie.net/__cb20130822100032/spongebob/images/c/cf/Patrick.png) no-repeat;
  background-size: cover;
  border:#FFCC00 1px solid;
  border-radius: 10px;
  width:71px;
  height:71px;
  float:left;
  margin:10px;
  padding:20px;
  font-size:85px;
  cursor:pointer;
  text-align:center;
}
/* Start button */
nav#nav1{ margin-top: 30px;}
nav#nav1 > a{
  background: #FF9999;
  color: #000;
  padding: 10px;
  text-decoration: none;
  border-radius: 5px;
  font-family: "Arial Black", Gadget, sans-serif;
}
nav#nav1 > a:hover{ background: #BBEA00;}
nav#nav1 > a:active{ background: #EEFFA8;}
</style>
<script>
var startScreen = (function(input) {
 
    // the red component of rgb
    var hue = 0; 
    // are we moving toward red or black?
    var direction = 1; 
    var transitioning = false;
 
    // record the input state from last frame
    // because we need to compare it in the
    // current frame
    var wasButtonDown = false;
 
    // a helper function
    // used internally to draw the text in
    // in the center of the canvas (with respect
    // to the x coordinate)
    function centerText(ctx, text, y) {
        var measurement = ctx.measureText(text);
        var x = (ctx.canvas.width - measurement.width) / 2;
        ctx.fillText(text, x, y);
    }
    
    // draw the main menu to the canvas
    function draw(ctx, elapsed) {
        
        // let's draw the text in the middle of the canvas
        // note that it's ineffecient to calculate this 
        // in every frame since it never changes 
        // however, I leave it here for simplicity
        var y = ctx.canvas.height / 2;
        
        // create a css color from the `hue`
        var color = 'rgb(' + hue + ',0,0)';
        
        // clear the entire canvas
        // (this is not strictly necessary since we are always
        // updating the same pixels for this screen, however it
        // is generally what you need to do.)
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
 
        // draw the title of the game
        // this is static and doesn't change
        ctx.fillStyle = 'white';
        ctx.font = '48px monospace';
        centerText(ctx, 'My Awesome Game', y);
 
        // draw instructions to the player
        // this animates the color based on the value of `hue`
        ctx.fillStyle = color;
        ctx.font = '24px monospace';
        centerText(ctx, 'click to begin', y + 30);
    }
 
    // update the color we're drawing and
    // check for input from the user
    function update() {
        // we want `hue` to oscillate between 0 and 255
        hue += 1 * direction;
        if (hue > 255) direction = -1;
        if (hue < 0) direction = 1;
        
        // note that this logic is dependent on the frame rate,
        // that means if the frame rate is slow then the animation
        // is slow. 
        // we could make it indepedent on the frame rate, but we'll 
        // come to that later.
 
        // here we magically capture the state of the mouse
        // notice that we are not dealing with events inside the game
        // loop.
        // we'll come back to this too.
        var isButtonDown = input.isButtonDown();
 
        // we want to know if the input (mouse click) _just_ happened
        // that means we only want to transition away from the menu to the
        // game if there _was_ input on the last frame _but none_ on the 
        // current one.
        var mouseJustClicked = !isButtonDown && wasButtonDown;
 
        // we also check the value of `transitioning` so that we don't 
        // initiate the transition logic more the once (like if the player
        // clicked the mouse repeatedly before we finished transitioning)
        if (mouseJustClicked && !transitioning) {
            transitioning = true;
            // do something here to transition to the actual game
        }
 
        // record the state of input for use in the next frame
        wasButtonDown = isButtonDown;
    }
 
    // this is the object that will be `startScreen`
    return {
        draw: draw,
        update: update
    };
 
}());
var noise = new Audio();
noise.src = "http://fsb.zedge.net/dl/ringtone/7d5a285cef34fd6fa5e643d1659a5b36/danger_man.mp3?ref=www&type=mc"
// Tiles
var memory_array = ['A','A','B','B','C','C','D','D','E','E','F','F','G','G','H','H','I','I','J','J','K','K','L','L'];
var memory_values = [];
var memory_tile_ids = [];
var tiles_flipped = 0;
Array.prototype.memory_tile_shuffle = function(){
    var i = this.length, j, temp;
    while(--i > 0){
        j = Math.floor(Math.random() * (i+1));
        temp = this[j];
        this[j] = this[i];
        this[i] = temp;
    }
}
function newBoard(){
  tiles_flipped = 0;
  var output = '';
    memory_array.memory_tile_shuffle();
  for(var i = 0; i < memory_array.length; i++){
    output += '<div id="tile_'+i+'" onclick="memoryFlipTile(this,\''+memory_array[i]+'\')"></div>';
  }
  document.getElementById('memory_board').innerHTML = output;
}
function memoryFlipTile(tile,val){
  if(tile.innerHTML == "" && memory_values.length < 2){
    // Tile background color
    tile.style.background = '#66FF33';
    tile.innerHTML = val;
    // No tiles flipped
    if(memory_values.length == 0){
      memory_values.push(val);
      memory_tile_ids.push(tile.id);
      // 1 tile flipped
    } else if(memory_values.length == 1){
      memory_values.push(val);
      memory_tile_ids.push(tile.id);
      // 2 tiles flipped
      if(memory_values[0] == memory_values[1]){
        tiles_flipped += 2;
        // User made a tile match. Clear both arrays
        memory_values = [];
              memory_tile_ids = [];
        // Checks to see if all the tiles are flipped over
        if(tiles_flipped == memory_array.length){
          // New Game Alert
          alert("New Game");
          //Randomly shuffles tiles
          document.getElementById('memory_board').innerHTML = "";
          newBoard();
        }
        //If no match is made
      } else {
        function flip2Back(){
            // Flip the 2 tiles back over
            var tile_1 = document.getElementById(memory_tile_ids[0]);
            var tile_2 = document.getElementById(memory_tile_ids[1]);
            tile_1.style.background = 'url(http://img2.wikia.nocookie.net/__cb20130822100032/spongebob/images/c/cf/Patrick.png) no-repeat';
                  tile_1.innerHTML = "";
            tile_2.style.background = 'url(http://img2.wikia.nocookie.net/__cb20130822100032/spongebob/images/c/cf/Patrick.png) no-repeat';
                  tile_2.innerHTML = "";
            // Clear both arrays
            memory_values = [];
                  memory_tile_ids = [];
        }
        // Card flip back over speed 1 second
        setTimeout(flip2Back, 1000);
      }
    }
  }
}
</script>
<title>Memory Game</title>
</head>
<body>
 <div id="SplashScreen">
<h1>Game Title</h1>
<input id="StartButton" type="button" value="Start"/>
</div>

<canvas id="GameCanvas" style="display: none;">Game Stuff</canvas>

<script>
    ("#StartButton").click(function () {
        ("#SplashScreen").hide();
        ("#GameCanvas").show();
    });
</script>
<nav id ="nav1">
  <a href="#" onmousedown="noise.play()">Start</a>
</nav>
<div id="memory_board"></div>

<script>
// Calls new board
newBoard();
</script>
</body>
</html>